<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录日常，谢谢大家">
<meta property="og:type" content="website">
<meta property="og:title" content="geek720的日常">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="geek720的日常">
<meta property="og:description" content="记录日常，谢谢大家">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="geek720的日常">
<meta name="twitter:description" content="记录日常，谢谢大家">






  <link rel="canonical" href="http://yoursite.com/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>geek720的日常</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">geek720的日常</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">一名不愿透露姓名的程序员</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/04/四种常见的 POST 提交数据方式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geek720">
      <meta itemprop="description" content="记录日常，谢谢大家">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geek720的日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/03/04/四种常见的 POST 提交数据方式/" class="post-title-link" itemprop="http://yoursite.com/index.html">四种常见的 POST 提交数据方式</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-03-04 14:55:47 / 修改时间：14:56:22" itemprop="dateCreated datePublished" datetime="2020-03-04T14:55:47+08:00">2020-03-04</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="四种常见的-POST-提交数据方式"><a href="#四种常见的-POST-提交数据方式" class="headerlink" title="四种常见的 POST 提交数据方式"></a>四种常见的 POST 提交数据方式</h1><p>我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：<del>状态行</del>请求行、请求头、消息主体。类似于下面这样：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">method</span>&gt;</span> <span class="tag">&lt;<span class="name">request-URL</span>&gt;</span> <span class="tag">&lt;<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">headers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entity-body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。</p>
<p>服务端通常是根据请求头（Request Headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。</p>
<p>POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分</p>
<h3 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h3><p>最常见的POST提交数据方式，也是默认常用的方式。如果不设置Content-type属性，就会默认该方式提交数据，并且提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持</p>
<h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h3><p>上传文件时所用的方式，而且必须让表单的 enctyped等于 multipart/form-data。</p>
<h3 id="application-json"><a href="#application-json" class="headerlink" title="application/json"></a>application/json</h3><p>这种方式的特点是可以方便的提交复杂的结构化数据</p>
<h3 id="text-xml"><a href="#text-xml" class="headerlink" title="text/xml"></a>text/xml</h3><p>基本废弃,它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/26/书法高效入门攻略/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geek720">
      <meta itemprop="description" content="记录日常，谢谢大家">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geek720的日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/26/书法高效入门攻略/" class="post-title-link" itemprop="http://yoursite.com/index.html">书法高效入门攻略</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-26 23:11:40 / 修改时间：23:26:38" itemprop="dateCreated datePublished" datetime="2020-02-26T23:11:40+08:00">2020-02-26</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="握笔"><a href="#握笔" class="headerlink" title="握笔"></a>握笔</h2><p><img src="https://wx4.sinaimg.cn/mw690/e7124480ly1gc8c2pumetj20ec07iaan.jpg" alt=""></p>
<h2 id="练习方法"><a href="#练习方法" class="headerlink" title="练习方法"></a>练习方法</h2><p><img src="https://wx3.sinaimg.cn/mw690/e7124480ly1gc8c2qo6pxj20e80ap0ue.jpg" alt=""></p>
<p><img src="https://wx2.sinaimg.cn/mw690/e7124480ly1gc8c2ra0ggj20e80izwhs.jpg" alt=""></p>
<p><img src="https://wx3.sinaimg.cn/mw690/e7124480ly1gc8c2rdhufj20e80ct41f.jpg" alt=""></p>
<p><img src="https://wx4.sinaimg.cn/mw690/e7124480ly1gc8c2rhpdaj20e80izq6p.jpg" alt=""></p>
<p><img src="https://wx4.sinaimg.cn/mw690/e7124480ly1gc8c2rm0lgj20e80izq6u.jpg" alt=""></p>
<p><img src="https://wx2.sinaimg.cn/mw690/e7124480ly1gc8c2rq6gfj20e80izdjg.jpg" alt=""></p>
<h2 id="点横撇捺"><a href="#点横撇捺" class="headerlink" title="点横撇捺"></a>点横撇捺</h2><p><img src="https://wx4.sinaimg.cn/mw690/e7124480ly1gc8c2q4uq0j20e80apjsw.jpg" alt="撇"></p>
<p><img src="https://wx3.sinaimg.cn/mw690/e7124480ly1gc8c2qe092j20e80ap75v.jpg" alt="捺"></p>
<p><img src="https://wx4.sinaimg.cn/mw690/e7124480ly1gc8c2rvbszj20e80iyac9.jpg" alt=""></p>
<p><img src="https://wx4.sinaimg.cn/mw690/e7124480ly1gc8c2sgddoj20v90nigpf.jpg" alt=""></p>
<p><img src="https://wx1.sinaimg.cn/mw690/e7124480ly1gc8c2ryxuxj20e80ap75p.jpg" alt=""></p>
<p><img src="https://wx3.sinaimg.cn/mw690/e7124480ly1gc8c2s6x1jj20e80iygnm.jpg" alt=""></p>
<p><img src="https://wx4.sinaimg.cn/mw690/e7124480ly1gc8c2sayfbj20e80iygnm.jpg" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/05/JavaScript的一些思考，观察者模式和发布订阅模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geek720">
      <meta itemprop="description" content="记录日常，谢谢大家">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geek720的日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/05/JavaScript的一些思考，观察者模式和发布订阅模式/" class="post-title-link" itemprop="http://yoursite.com/index.html">JavaScript的一些思考：观察者模式和发布订阅模式</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-05 14:11:37 / 修改时间：14:12:51" itemprop="dateCreated datePublished" datetime="2019-08-05T14:11:37+08:00">2019-08-05</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>一天，小猪佩奇去了一家西餐厅，点了一份西冷牛扒，还叫了圣女果。后来服务员上了一碟番茄：佩奇小姐，这是你的「圣女果」。佩奇猪一眼就看出了猫腻：这tm是番茄，不是圣女果啊！于是就跟服务员理论起来：这是番茄不是圣女果，不是！服务员一脸懵逼：番茄不就是圣女果吗？…佩奇猪一脸「黑人问号」了：番茄是菜，圣女果是水果，这能一样？？？</p>
<hr>
<p>观察者模式和发布-订阅模式大概就是番茄和圣女果的关系一样，剪不断理还乱。我相信绝大多数js开发者人为两者关系是一样的。只是两种不同写法罢了。在阅读了MSN上的官方文档之前，我也是这样认为的。但是在这之后，我觉得两者差距还是有的，首先是名字。如果是两种不同写法，那为何名字不一样呢？</p>
<h2 id="二、区别"><a href="#二、区别" class="headerlink" title="二、区别"></a>二、区别</h2><p>先用一张图片说明两个模式的不同，左边是观察者模式，右边是发布-订阅模式。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g5or0dqwrij30ki0bst8w.jpg" alt="区别"></p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>从图中可以看出来，一个对象（subject）维持一群依赖它的对象（subject）。从数学的角度来讲，这是一种一对多的关系。在这个模式里，观察者（Observer）直接订阅（subscribe）主题（Subject），而当主题被激活的时候，会触发（fire）观察者里的事件。</p>
<h4 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h4><p>可以看出，观察者模式中，观察者和主题两个对象互相依赖着，没有解耦。在发布-订阅模式中在两者之中多了一层Event Bus，以此来解耦观察者和主题。</p>
<blockquote>
<p>注：事件总线也有说法叫为调度中心。本质上是一样的。不过因为写Vue时候习惯用Event Bus来说了，所以本文的调度中心皆以事件总线称呼。</p>
</blockquote>
<p>两者最主要的区别就是，有没有一层中间的事件总线将两者解耦。大多数js开发者认为两种模式其实是一种模式两种写法的原因大概是它们都实现了一个关键的功能：发布事件-订阅事件并触发。</p>
<h2 id="简单用代码实现"><a href="#简单用代码实现" class="headerlink" title="简单用代码实现"></a>简单用代码实现</h2><h4 id="观察者模式-1"><a href="#观察者模式-1" class="headerlink" title="观察者模式"></a>观察者模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function Observer(data) &#123;</span><br><span class="line">    this.data = data;</span><br><span class="line">&#125;</span><br><span class="line">Observer.prototype = &#123;</span><br><span class="line">    notify() &#123;</span><br><span class="line">        console.log(&apos;notify&apos;, this.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Subject() &#123;</span><br><span class="line">    this.subs = [];</span><br><span class="line">    this.subscribe = function(sub) &#123;</span><br><span class="line">        this.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">    this.unsubscribe = function(sub) &#123;</span><br><span class="line">        const index = this.subs.indexOf(sub)</span><br><span class="line">        if(index &gt; -1)&#123;</span><br><span class="line">            this.subs.splice(index , 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.fire = function() &#123;</span><br><span class="line">        this.subs.forEach((sub) =&gt; &#123;</span><br><span class="line">            sub.notify()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const o1 = new Observer(&apos;hello1&apos;)</span><br><span class="line">const o2 = new Observer(&apos;hello2&apos;)</span><br><span class="line">const sub1 = new Subject()</span><br><span class="line">sub1.subscribe(o1)</span><br><span class="line">sub1.subscribe(o2)</span><br><span class="line">sub1.fire()</span><br></pre></td></tr></table></figure>
<h4 id="观察者模式在Dom中的实践"><a href="#观察者模式在Dom中的实践" class="headerlink" title="观察者模式在Dom中的实践"></a>观察者模式在Dom中的实践</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Dom &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.events = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addEventListener (event, callback) &#123;</span><br><span class="line">        if (!this.events[event]) &#123;</span><br><span class="line">            this.events[event] = []</span><br><span class="line">        &#125;</span><br><span class="line">        this.events[event].push(callback)</span><br><span class="line">    &#125;</span><br><span class="line">    fireEvent(e) &#123;</span><br><span class="line">        if (!this.events[e]) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        this.events[e].forEach((item) =&gt; &#123;</span><br><span class="line">            item()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const dom = new Dom();</span><br><span class="line">dom.addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;onclick&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">dom.addEventListener(&apos;scroll&apos;, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;onscroll&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">dom.fireEvent(&apos;click&apos;)</span><br><span class="line">dom.fireEvent(&apos;scroll&apos;)</span><br></pre></td></tr></table></figure>
<h4 id="发布-订阅模式-1"><a href="#发布-订阅模式-1" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class EventChannel &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.subject = &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    _hasSubject(sub) &#123;</span><br><span class="line">        return this.subject[sub] ? true : false</span><br><span class="line">    &#125;</span><br><span class="line">    on(sub, cb) &#123;</span><br><span class="line">        if (!this._hasSubject(sub)) &#123;</span><br><span class="line">            this.subject[sub] = []</span><br><span class="line">        &#125;</span><br><span class="line">        this.subject[sub].push(cb)</span><br><span class="line">    &#125;</span><br><span class="line">    emit(sub, ...data) &#123;</span><br><span class="line">        if (!this._hasSubject(sub)) &#123;</span><br><span class="line">            return </span><br><span class="line">        &#125;</span><br><span class="line">        this.subject[sub].forEach((item) =&gt; &#123;</span><br><span class="line">            item(...data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const eventBus = new EventChannel()</span><br><span class="line"></span><br><span class="line">const people = function(val) &#123;</span><br><span class="line">    console.log(&apos;我收到了新的商品通知&apos;, val)</span><br><span class="line">&#125;</span><br><span class="line">eventBus.on(&apos;newItem&apos;, people);</span><br><span class="line"></span><br><span class="line">const merchat = function(val) &#123;</span><br><span class="line">    const item = &#123;</span><br><span class="line">        item: val</span><br><span class="line">    &#125;</span><br><span class="line">    eventBus.emit(&apos;newItem&apos;, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">merchat(&apos;Book&apos;)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/22/axios封装属于自己业务的请求库总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geek720">
      <meta itemprop="description" content="记录日常，谢谢大家">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geek720的日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/22/axios封装属于自己业务的请求库总结/" class="post-title-link" itemprop="http://yoursite.com/index.html">axios封装属于自己业务的请求库总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-22 14:01:46" itemprop="dateCreated datePublished" datetime="2019-01-22T14:01:46+08:00">2019-01-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-18 14:02:57" itemprop="dateModified" datetime="2019-03-18T14:02:57+08:00">2019-03-18</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数据请求是我们开发中非常重要的一环，如何优雅地进行抽象处理，不是一件很容易的事情，也是经常被忽略的事情，处理不好的话，重复的代码散落在各处，维护成本极高。<br>所以我们需要好好梳理下数据请求涉及到哪些方面，对它有整体的管控，从而设计出扩展性高的方案。</p>
<h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>首先，我们处理下参数的配置，</p>
<ul>
<li>首先需要防止 CSRF，那我们需要在请求中的 headers 加上 X-XSRF-TOKEN</li>
<li>还需要一个params请求体，请求体需要在post和get请求做一个区分</li>
<li>除了防止csrf的header配置，如果另外请求有别的配置，比如content-type之类的，需要一个config<br>所以，我们将这一部分，封装成一个request.js文件，并export出几个请求方法，post和get<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;;</span><br><span class="line"></span><br><span class="line">// The http header that carries the xsrf token value &#123; X-XSRF-TOKEN: &apos;&apos; &#125;</span><br><span class="line">const csrfConfig = &#123;</span><br><span class="line">  &apos;X-XSRF-TOKEN&apos;: &apos;&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">// Build uniform request</span><br><span class="line">async function buildRequest(method, url, params, options) &#123;</span><br><span class="line">  let param = &#123;&#125;;</span><br><span class="line">  let config = &#123;&#125;;</span><br><span class="line">  if (method === &apos;get&apos;) &#123;</span><br><span class="line">    param = &#123; params, ...options &#125;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    param = JSON.stringify(params);</span><br><span class="line">    config = &#123;</span><br><span class="line">      headers: &#123;</span><br><span class="line">        ...csrfConfig,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    config = Object.assign(&#123;&#125;, config, options);</span><br><span class="line">  &#125;</span><br><span class="line">  return axios[method](url, param, config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const get = (url, params = &#123;&#125;, options) =&gt; buildRequest(&apos;get&apos;, url, params, options);</span><br><span class="line">export const post = (url, params = &#123;&#125;, options) =&gt; buildRequest(&apos;post&apos;, url, params, options);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样的话，我们对外就暴露出 get 和 post 的方法，其他请求类似，在此只用 get 和 post 作为示例，入参分别是 API地址，数据 和 扩展配置</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li>全局异常，也可以说是通用的异常，比如服务端返回503，网络异常，登录失效，无权限等，这些异常是可以预料并可控的，只要和服务端约定好格式，捕获下异常再展示出来即可。</li>
<li>业务异常，指的是和业务逻辑紧密相关的，比如提交失败，数据校验失败等，这些异常往往每个接口有不一样的情况，而且需要个性化展示错误，所以这部分可能不能进行统一处理，有时候需要把展示错误交到 View 层去实现。<br>之前的方案是在请求中不断地去catch，但是发现这样冗余代码太多，如果这部分异常处理需要抽象出来，则要用到axios 提供的 interceptors 功能，这样可以将异常的处理和核心的请求方法隔离出来，毕竟这部分是要和 UI 进行交互的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;;</span><br><span class="line"></span><br><span class="line">// Add a response interceptor</span><br><span class="line">axios.interceptors.response.use((response) =&gt; &#123;</span><br><span class="line">  const &#123; config, data &#125; = response;</span><br><span class="line">  // 和服务端约定的 Code</span><br><span class="line">  const &#123; code &#125; = data;</span><br><span class="line">  switch (code) &#123;</span><br><span class="line">    case 200:</span><br><span class="line">      return data;</span><br><span class="line">    case 401:</span><br><span class="line">      // 登录失效</span><br><span class="line">      break;</span><br><span class="line">    case 403:</span><br><span class="line">      // 无权限</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  if (config.showError) &#123;</span><br><span class="line">    // 接口配置指定需要个性化展示错误</span><br><span class="line">    return Promise.reject(data);</span><br><span class="line">  &#125;</span><br><span class="line">  // 默认展示错误</span><br><span class="line">  // ... Toast error</span><br><span class="line">&#125;, (error) =&gt; &#123;</span><br><span class="line">  // 通用错误</span><br><span class="line">  if (axios.isCancel(error)) &#123;</span><br><span class="line">    // Request cancel</span><br><span class="line">  &#125; else if (navigator &amp;&amp; !navigator.onLine) &#123;</span><br><span class="line">    // Network is disconnect</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Other error</span><br><span class="line">  &#125;</span><br><span class="line">  return Promise.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="请求监控"><a href="#请求监控" class="headerlink" title="请求监控"></a>请求监控</h3><p>请求监控这块和异常处理类似，只不过这里只是记录情况，不涉及到 UI 上的交互或者和业务代码的交互，所以可以把这部分逻辑直接写在异常处理那里，或者在请求后再添加一个拦截器，单独处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use((response) =&gt; &#123;</span><br><span class="line">  const &#123; status, data, config &#125; = response;</span><br><span class="line">  // 根据返回的数据和接口参数配置，对请求进行埋点</span><br><span class="line">&#125;, (error) =&gt; &#123;</span><br><span class="line">  // 根据返回的数据和接口参数配置，对请求进行埋点</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>好了，到现在为止，参数配置、异常处理 和 请求监控 都设计完了，有三个文件：</p>
<p>request.js：请求库配置，对外暴露出 get，post 方法。<br>error.js：请求的一些异常处理，涉及到和外面对接的是该接口是否需要个性化展示错误。<br>monitor.js：请求的情况记录，比较独立的一块。</p>
<p>那在页面上调用的时候可以这样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; get, post &#125; from &apos;request.js&apos;;</span><br><span class="line"></span><br><span class="line">get(&apos;/user/info&apos;).then((data) =&gt; &#123;&#125;);</span><br><span class="line">post(&apos;/user/update&apos;, &#123; name: &apos;beyondxgb&apos; &#125;, &#123; showError: true &#125;).then((data) =&gt; &#123;</span><br><span class="line">  if (data.code !== 200) &#123;</span><br><span class="line">    // 展示错误</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // do something</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/17/在vue下封装echarts公共组件的总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geek720">
      <meta itemprop="description" content="记录日常，谢谢大家">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geek720的日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/17/在vue下封装echarts公共组件的总结/" class="post-title-link" itemprop="http://yoursite.com/index.html">在vue下封装echarts公共组件的总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-17 16:48:12" itemprop="dateCreated datePublished" datetime="2019-01-17T16:48:12+08:00">2019-01-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-18 14:02:19" itemprop="dateModified" datetime="2019-03-18T14:02:19+08:00">2019-03-18</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这几天公司里边有一个项目，叫做日控制台，该项目是在webview下的一个webapp，使用vue构建，项目中要求使用许多自定义的图表。考察了许多图表组件之后，发现echarts是所有表库中，最灵活，特效最好看的一种。</p>
<h2 id="一、构建基础公共组件"><a href="#一、构建基础公共组件" class="headerlink" title="一、构建基础公共组件"></a>一、构建基础公共组件</h2><h4 id="1、实现基础功能"><a href="#1、实现基础功能" class="headerlink" title="1、实现基础功能"></a>1、实现基础功能</h4><p>在echart官网上搜索到，如何使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 1. 获取一个用于挂在 echarts 的 DOM 元素</span><br><span class="line">let $echartsDOM = document.getElementById(&apos;echarts-dom&apos;)</span><br><span class="line"></span><br><span class="line"># 2. 初始化</span><br><span class="line">let myEcharts = echarts.init($echartsDOM)</span><br><span class="line"></span><br><span class="line"># 3. 设置配置项</span><br><span class="line">let option = &#123;...&#125;</span><br><span class="line"></span><br><span class="line"># 4. 为 echarts 指定配置</span><br><span class="line">myEcharts.setOption(option)</span><br></pre></td></tr></table></figure></p>
<p>使用echart的步骤也就这几部，就是先获取到承载echart实例的dom实例，然后调用init()方法初始化图标实例，最后调用setOption()方法传入配置项<br>这几步都要在vue的mounted方法下实现.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">      let $echartsDOM = document.getElementById(&apos;echarts-dom&apos;)</span><br><span class="line">      let myEcharts = echarts.init($echartsDOM)</span><br><span class="line">      let option = &#123;</span><br><span class="line">        title: &#123;</span><br><span class="line">          text: &apos;ECharts 入门示例&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: &#123;&#125;,</span><br><span class="line">        legend: &#123;</span><br><span class="line">          data: [&apos;销量&apos;]</span><br><span class="line">        &#125;,</span><br><span class="line">        xAxis: &#123;</span><br><span class="line">            data: [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;]</span><br><span class="line">        &#125;,</span><br><span class="line">        yAxis: &#123;&#125;,</span><br><span class="line">        series: [&#123;</span><br><span class="line">            name: &apos;销量&apos;,</span><br><span class="line">            type: &apos;bar&apos;,</span><br><span class="line">            data: [5, 20, 36, 10, 10, 20]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">    myEcharts.setOption(option)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：在 Vue 中，首先我们需要使用 import echarts from ‘echarts’ 以引入 echarts。</p>
<h2 id="二、组件化"><a href="#二、组件化" class="headerlink" title="二、组件化"></a>二、组件化</h2><p>思路很简单，就是将业务上用到的图表，比如柱状图、折线图，通通封装成组件，然后再main app文件中调用，通过分析，可以通过传props，来改变setOption()方法中的对象，达到封装不同图表组件的目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ocEcharts class=&quot;echarts-container&quot; :options=&quot;ocoptions&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>将之前的options转移到main app中的data对象之中。<br>注：echarts图表要求承载的容器具有固定的宽高才能正常显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.echarts-container&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 20rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1、组件优化-props的series校验"><a href="#1、组件优化-props的series校验" class="headerlink" title="1、组件优化-props的series校验"></a>1、组件优化-props的series校验</h4><p>如果在传入组件的props中传入了空对象，就会发现，图表会抛出一个错误，即</p>
<blockquote>
<p>Error: Option should contains series.</p>
</blockquote>
<p>原因就是传入的 option 配置对象不含有 series 键，所以，默认值处理是需要存在的，即当调用方传入的对象为空或不存在 series 配置时，应在页面上显示一些提示（ 对用户友好的提示，而不是对编程人员 ），即避免因报错而造成空白的情况。<br>此外，当我们像之前那样给 option 这一参数进行类型限制后，倘若调用方传入非对象类型，Vue 会直接抛出错误——这一结果也不是我们想要的。我们应该取消类型限制，并在 option 发生变化时进行依次以下判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 1. 是否为对象；</span><br><span class="line">export function isObject(option) &#123;</span><br><span class="line">  return Object.prototype.isPrototypeOf(option)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 是否为空对象；</span><br><span class="line">export function isEmptyObject(option) &#123;</span><br><span class="line">  return Object.keys(option).length === 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 是否包含 series 键；</span><br><span class="line">export function hasSeriesKey(option) &#123;</span><br><span class="line">  return !!option[&apos;series&apos;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4. series 是否为数组；</span><br><span class="line">export function isSeriesArray(option) &#123;</span><br><span class="line">  return Array.isArray(option[&apos;series&apos;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 5. series 数组是否为空。</span><br><span class="line">export function isSeriesEmpty(option) &#123;</span><br><span class="line">  return option[&apos;series&apos;].length === 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function isValidOption(option) &#123;</span><br><span class="line">  return isObject(option) &amp;&amp; !isEmptyObject(option)</span><br><span class="line">    &amp;&amp; hasSeriesKey(option)</span><br><span class="line">    &amp;&amp; isSeriesArray(option) &amp;&amp; !isSeriesEmpty(option)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在组件中引入最后的isValidOption方法作为判断，我们先使用一个watch监听options的变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">   options(options)&#123;</span><br><span class="line">     this.checkAndSetOption()</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> methods: &#123;</span><br><span class="line">   checkAndSetOption()&#123;</span><br><span class="line">     let options = this.options</span><br><span class="line">     if(isValidOption(options))&#123;</span><br><span class="line">       this.myEcharts.setOption(options)</span><br><span class="line">       this.isOptionAbnormal = false</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">       this.isOptionAbnormal = true</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的checkAndSetOption方法是判断传入的option是否合法，如果合法，就执行setOption，isOptionAbnormal变量是监控页面是否显示options非法的flag。<br>同样的dom样式上的改变，也要使用v-show来判断isOptionAbnormal是否要渲染图表和渲染错误信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;shadow&quot; v-show=&quot;isOptionAbnormal&quot;&gt;数据为空&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;oc_echarts_container&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;echarts&quot; id=&quot;echarts-dom&quot; v-show=&quot;!isOptionAbnormal&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.oc_echarts_container, .echarts &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.shadow &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">  font-size: 1rem;</span><br><span class="line">  color: #8590a6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、增强组件功能-数据加载提示"><a href="#2、增强组件功能-数据加载提示" class="headerlink" title="2、增强组件功能 - 数据加载提示"></a>2、增强组件功能 - 数据加载提示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;loading&quot; v-show=&quot;isLoading&quot;&gt;</span><br><span class="line">        数据加载中...</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>在组件内部需要一个外部的props，isLoading，但是这里需要注意，在 Vue 中，v-show 使用 display 控制组件的显隐。而当 echart init 的时候，如果其挂载 DOM 的 v-show 处于 false 状态，则其 init 的对象宽高都是 0。即使之后 v-show 状态改变，由于 mounted 生命周期不会再次触发，从而使得 echarts 显示不正常。所以需要使用css的visibility来控制显隐。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    isChartVisible() &#123;</span><br><span class="line">       return !this.isLoading &amp;&amp; !this.isOptionAbnormal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;oc_echarts_container&quot;&gt;</span><br><span class="line">     &lt;div class=&quot;echarts&quot; id=&quot;echarts-dom&quot; :style=&quot;&#123;visibility: isChartVisible ? &apos;visible&apos; : &apos;hidden&apos;&#125;&quot; /&gt;</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3、组件复用-随机ID"><a href="#3、组件复用-随机ID" class="headerlink" title="3、组件复用-随机ID"></a>3、组件复用-随机ID</h4><p>echarts 进行 init 挂载时使用的是 DOM 元素的 ID。而在组件中，我们设置的 ID 是固定的（ 注意与 scoped css 进行区分 ）。如果多个组件的 ID 是相同的，只有一个组件会被 echarts 挂载。<br>所以我们要设定一个随机的randomId,赋值到承载echarts图表的dom元素的id中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;oc_echarts_container&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;echarts&quot; :id=&quot;randomId&quot; :style=&quot;&#123;visibility: isChartVisible ? &apos;visible&apos; : &apos;hidden&apos;&#125;&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、延迟加载"><a href="#三、延迟加载" class="headerlink" title="三、延迟加载"></a>三、延迟加载</h2><p>延迟加载是组件的一个优化，在业务的开发中可以看到，一个页面往往有着许多的图表，图标伴随着许多异步请求和canvas渲染，如果一次性渲染所有的图表会导致许多的性能问题。这里想到的一个解决方案就是延迟加载。<br>用通俗的话讲就是，页面滚动到哪张图表就去渲染哪一张图表。<br>完成这一功能需要以下步骤：</p>
<ol>
<li>监听页面滚动事件；</li>
<li>滚动事件中获取 echarts 的位置；</li>
<li>在页面当前位置达到 echarts 位置的时候进行 echarts 的初始化。</li>
</ol>
<h4 id="1、监听页面滚动"><a href="#1、监听页面滚动" class="headerlink" title="1、监听页面滚动"></a>1、监听页面滚动</h4><p>如果要监听页面滚动，需要用到dom的监听器，addEventListener(‘scroll’, [funciton])。这样就能为每一个组件附上监听事件。</p>
<h4 id="2、获取当前滚动下边界和组件的上边界"><a href="#2、获取当前滚动下边界和组件的上边界" class="headerlink" title="2、获取当前滚动下边界和组件的上边界"></a>2、获取当前滚动下边界和组件的上边界</h4><p>这一个步骤需要封装成一个函数，checkPosition()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">checkPosition() &#123;</span><br><span class="line">      let windowHeight = document.documentElement.clientHeight||window.innerHeight</span><br><span class="line">      let scrollTop = document.documentElement.scrollTop || document.body.scrollTop</span><br><span class="line">      let windowBottom = scrollTop + windowHeight</span><br><span class="line">      const selfTop = _.get(this.$refs, &apos;selfEcharts.offsetTop&apos;, 0);</span><br><span class="line">      if(windowBottom &gt;= selfTop) &#123;</span><br><span class="line">        this.isPositionReady = true</span><br><span class="line">        this.checkAndSetOption()</span><br><span class="line">        window.removeEventListener(&apos;scroll&apos;,  this.scrollEvent)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p>
<ul>
<li>windowBottom（滑动的下边界）  = scrollTop（屏幕当前滑动的距离） + windowHeight（窗口的高度）</li>
<li>selfTop（当前组件的顶部位置）<br>当第一个变量大于第二个变量时，就认为滑动到了该图表组件，就开开启加载<h4 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      myEcharts: null,</span><br><span class="line">      isOptionAbnormal: false,</span><br><span class="line">      randomId: &apos;echarts-dom&apos; + Date.now() + Math.random(),</span><br><span class="line">      scrollEvent:  _.throttle(this.checkPosition, 500), // 滑动事件</span><br><span class="line">      isPositionReady: false, //控制数据异步与页面滚动先后顺序的flag</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    let $echartsDOM = document.getElementById(this.randomId)</span><br><span class="line">    if(!$echartsDOM) return</span><br><span class="line">    this.myEcharts = echarts.init($echartsDOM)</span><br><span class="line">        // 第一次未滑动的时候</span><br><span class="line">    this.checkPosition()</span><br><span class="line">        //滑动之后的监听</span><br><span class="line">    window.addEventListener(&apos;scroll&apos;, this.scrollEvent)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>checkPosition方法不仅要在scroll监听事件中调用，在组件第一次渲染的时候也要调用一次进行初始化，不然，组件无法正常渲染图表。</p>
<h4 id="4、节流"><a href="#4、节流" class="headerlink" title="4、节流"></a>4、节流</h4><p>组件代码经过测试之后发现，如果滚动过于快速，会不停的调用checkPosition(),关键是这个方法会不停的去setOption()，所以以上代码均采用了lodash的throttle节流方法，在500毫秒内只允许调用一次。</p>
<h4 id="5、解绑监听事件"><a href="#5、解绑监听事件" class="headerlink" title="5、解绑监听事件"></a>5、解绑监听事件</h4><p>解绑事件，组件中有设定监听器，如果该图表已经被加载了，那么这个监听器就没有作用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.removeEventListener(&apos;scroll&apos;,  this.scrollEvent)</span><br></pre></td></tr></table></figure></p>
<p>这段代码就是解绑监听器，多多少少会优化一下速度吧。因为增加监听和解绑监听的时间函数要求一致，所以在data中新增了scrollEvent，顺便把节流函数一起加了上去。</p>
<h4 id="6、请求异步控制setOption"><a href="#6、请求异步控制setOption" class="headerlink" title="6、请求异步控制setOption"></a>6、请求异步控制setOption</h4><p>由于用于渲染 echarts 的数据常常是异步获取的，也就是说，option 可能会在异步调用结束之后更新，从而触发 option 的 watch，进而导致 this.checkOption() 执行，最终使得 setOption 在页面没有滚动到合适位置时就触发了。<br>为了解决这个问题，我们应该让 setOption 的过程受制于一个标识位，而该标识位会在页面滚动到合适位置时置为 true，从而杜绝由于 option 更新、触发 watch 而导致的漏洞。<br>首先，我们要添加一个新的 data，取名为为 isPositionReady，然后，在 checkAndSetOption() 中加入对该标识位的判断：最后，在位置检测方法 checkPosition() 中，当达到合适位置时，将该标识位置为 true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">checkPosition() &#123;</span><br><span class="line"> // ....</span><br><span class="line">  if(windowBottom &gt;= selfTop) &#123;</span><br><span class="line">    this.isPositionReady = true</span><br><span class="line">    // ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">checkAndSetOption() &#123;</span><br><span class="line">// ....</span><br><span class="line">  if(!this.isPositionReady) return </span><br><span class="line">  //....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、echarts重绘"><a href="#四、echarts重绘" class="headerlink" title="四、echarts重绘"></a>四、echarts重绘</h2><p>这里的重绘指的是 ehcarts 中的 resize() 方法。用于在某些时刻进行 echarts 的调整，包括：</p>
<ul>
<li>组件宽度设置为百分比，浏览器宽度发生变化时；</li>
<li>页面收缩元素状态改变，如侧边栏收缩导致内容区宽度变化；</li>
</ul>
<h4 id="1、页面宽度改变"><a href="#1、页面宽度改变" class="headerlink" title="1、页面宽度改变"></a>1、页面宽度改变</h4><p>继续增加监听器就能完成</p>
<pre><code>window.addEventListener(&apos;resize&apos;, _.throttle(() =&gt; {
    this.myEcharts.resize()
    console.log(&apos;---&apos;)
}, 500))
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/使用es6新的class语法来体验js的面向对象编程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geek720">
      <meta itemprop="description" content="记录日常，谢谢大家">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geek720的日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/25/使用es6新的class语法来体验js的面向对象编程/" class="post-title-link" itemprop="http://yoursite.com/index.html">使用es6新的class语法来体验js的面向对象编程</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-25 17:14:26 / 修改时间：17:14:55" itemprop="dateCreated datePublished" datetime="2018-12-25T17:14:26+08:00">2018-12-25</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天在看一本书，只有小小的一百多页，半天快看完半本了，名字叫《学习JavaScript数据结构预算法》.看下来的感受就是，短小精悍，适合复习一下大学学的数据结构。<br>在读到使用js实现栈的结构的时候，看到它的写法是之前的构造函数继承的写法，突发奇想，想用es6的语法改写一下试试，这是书上的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Stack() &#123;</span><br><span class="line">  var items = []</span><br><span class="line"></span><br><span class="line">  this.push = function(element) &#123;</span><br><span class="line">    items.push(element)</span><br><span class="line">  &#125;</span><br><span class="line">  this.pop = function() &#123;</span><br><span class="line">    return items.pop()</span><br><span class="line">  &#125;</span><br><span class="line">  this.peek = function() &#123;</span><br><span class="line">    return items[items.length - 1]</span><br><span class="line">  &#125;</span><br><span class="line">  this.isEmpty = function() &#123;</span><br><span class="line">    return items.length === 0</span><br><span class="line">  &#125;</span><br><span class="line">  this.size = function() &#123;</span><br><span class="line">    return items.length</span><br><span class="line">  &#125;</span><br><span class="line">  this.clear = function() &#123;</span><br><span class="line">    items = []</span><br><span class="line">  &#125;</span><br><span class="line">  this.print = function() &#123;</span><br><span class="line">    console.log(items.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>算不上是类的写法，只是在函数里定义了几个方法，去修改items的值而已，新写的写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Strack &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.item = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 栈的压入</span><br><span class="line">  push(value) &#123;</span><br><span class="line">    this.item.push(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 栈的弹出</span><br><span class="line">  pop() &#123;</span><br><span class="line">    this.item.pop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回栈顶元素</span><br><span class="line">  peek() &#123;</span><br><span class="line">    let lengthTemp = this.item.length</span><br><span class="line">    return this.item[lengthTemp - 1]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 判空</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    return this.item.length === 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // remove all</span><br><span class="line"></span><br><span class="line">  clear() &#123;</span><br><span class="line">    this.item = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // sum all items</span><br><span class="line">  size() &#123;</span><br><span class="line">    return this.item.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Strack</span><br></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const newStrack = new Strack()</span><br><span class="line">   newStrack.push(1)</span><br><span class="line">   newStrack.push(2)</span><br><span class="line">   newStrack.push(3)</span><br><span class="line">   newStrack.pop()</span><br><span class="line">   console.log(newStrack, newStrack);</span><br><span class="line">   console.log(&apos;newStrack is empty? : &apos;, newStrack.isEmpty());</span><br></pre></td></tr></table></figure></p>
<p>很简单，但是没有弄清楚，这样写和以前的写法有什么的本质的区别，这一点需要去研究一下。</p>
<h3 id="基于类的面向对象和基于原型的面向对象"><a href="#基于类的面向对象和基于原型的面向对象" class="headerlink" title="基于类的面向对象和基于原型的面向对象"></a>基于类的面向对象和基于原型的面向对象</h3><ul>
<li><p>基于类的面向对象<br>在基于类的面向对象语言中（比如Java和C++）， 是构建在类(class)和实例(instance)上的。其中类定义了所有用于具有某一特征对象的属性。类是抽象的事物， 而不是其所描述的全部对象中的任何特定的个体。另一方面， 一个实例是一个类的实例化，是其中的一个成员。</p>
</li>
<li><p>基于原型的面向对象<br>在基于原型的语言中（如JavaScript）并不存在这种区别：它只有对象！不论是构造函数(constructor)，实例(instance)，原型(prototype)本身都是对象。基于原型的语言具有所谓的原型对象的概念，新对象可以从中获得原始的属性。</p>
</li>
</ul>
<p>所以，在JavaScript中有一个很有意思的<strong>proto</strong>属性（ES6以下是非标准属性）用于访问其原型对象， 你会发现，上面提到的构造函数，实例，原型本身都有<strong>proto</strong>指向原型对象。其最后顺着原型链都会指向Object这个构造函数，然而Object的原型对象的原型是null，不信， 你可以尝试一下Object.prototype.<strong>proto</strong> === null为true。然而typeof null === ‘object’为true。到这里， 我相信你应该就能明白为什么JavaScript这类基于原型的语言中没有类和实例的区别， 而是万物皆对象！</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>js实现封装的办法和java其实差不多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  var smallName = &apos;xiaoming&apos;</span><br><span class="line">&#125;</span><br><span class="line">Person. prototype.sayHi = function() &#123;</span><br><span class="line">  console.log(&apos;hello&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码，定义了一个私有变量smallName和一个方法sayHi，我们并不能通过实例化Person去访问smallName，还有我们也不知道sayH是怎么实现的，这样就实现了封装。</p>
<h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><p>在es6以前，我最常使用的继承方式是使用protutype<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.career = function() &#123;</span><br><span class="line">      console.log(&apos;I am a Person&apos; + name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Person.prototype.sayHi = function () &#123;</span><br><span class="line">    console.log(&apos;my name is &apos; + this.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function Teacher(career) &#123;</span><br><span class="line">    this.career = function() &#123;</span><br><span class="line">      console.log(&apos;I am a &apos; + career + &apos;, my name is &apos; + this.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Teacher.prototype = new Person(&apos;Ma&apos;)</span><br><span class="line">Teacher.prototype.constructor = Teacher</span><br><span class="line"></span><br><span class="line">  var personOne  = new Person(&apos;Zhang&apos;)</span><br><span class="line">  personOne.career()</span><br><span class="line"></span><br><span class="line">  var teaMa = new Teacher(&apos;math&apos;)</span><br><span class="line">  console.log(teaMa);</span><br><span class="line">  teaMa.career()</span><br></pre></td></tr></table></figure></p>
<p>Person是一个父类，子类Teacher想要继承父类，就在它的prototype指向变为一个新的父类实例，同时将prototype的constructor属性指向自己,如果constructor属性不指回自己的话，将会导致<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(teaMa.constructor === Person)  // true</span><br></pre></td></tr></table></figure></p>
<p>这是一个重大错误，明明是Teacher实例化出来的，结果显示父类实例化的……<br>新实例化的Teacher有父类的name属性，这就实现了继承，同时Person和Teacher类都有career方法，他们通过函数覆盖实现了多态。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/18/Node笔记-fs文件模块/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geek720">
      <meta itemprop="description" content="记录日常，谢谢大家">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geek720的日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/18/Node笔记-fs文件模块/" class="post-title-link" itemprop="http://yoursite.com/index.html">Node笔记--------fs文件模块</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-18 17:36:36 / 修改时间：17:36:46" itemprop="dateCreated datePublished" datetime="2018-12-18T17:36:36+08:00">2018-12-18</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>fs是filesystem的缩写，基本上就是node对于文件系统操作封装的一些api</p>
<h3 id="一、文件的读写"><a href="#一、文件的读写" class="headerlink" title="一、文件的读写"></a>一、文件的读写</h3><p>文件的读写这里面的api有readFile(),writeFile(),和readFileSync(),writeFileSync()。前者是异步，后者是同步，两种不同的情况供开发者选择。</p>
<h5 id="readFile-和readFileSync"><a href="#readFile-和readFileSync" class="headerlink" title="readFile()和readFileSync()"></a>readFile()和readFileSync()</h5><p>readFile用于异步读取数据，他有几个参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>是否必须</th>
<th>例子</th>
<th>作用 </th>
</tr>
</thead>
<tbody>
<tr>
<td>文件的路径</td>
<td>是</td>
<td>‘./image.png’</td>
<td>可以是绝对路径，也可是相对路径，如果是相对路径，是相对于当前进程所在的路径 process.cwd(),官方文档上好像写也可以传一个buffer……还能是文件名和文件描述符（不知道是什么东西）</td>
</tr>
<tr>
<td>options配置</td>
<td>否</td>
<td>‘utf-8’</td>
<td>可以配置文件编码实例，默认是utf-8</td>
</tr>
<tr>
<td>读取完成后的回调参数</td>
<td>是</td>
<td>func (err, buffer) { }</td>
<td>该函数一参是发生错误时的错误对象，二参是代表文件内容的buffer实例</td>
</tr>
</tbody>
</table>
<p>如果，文件的路径是一个目录，会返回一个错误……freeBSD不会，好像基于平台…..<br>同步的方法readFileSync()和这个一样，使用的例子如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const text = fs.readFile(&apos;etc/passws&apos;, &apos;utf-8&apos; (error, buffer) =&gt; &#123;</span><br><span class="line">    if(error) throw err</span><br><span class="line">    console.log(buffer) </span><br><span class="line">  &#125;) &#123;</span><br><span class="line">&#125;</span><br><span class="line">//将文件按行拆成数组......</span><br><span class="line">text.split(/\r?\n/).forEach((item) =&gt; &#123;</span><br><span class="line">  console.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h5 id="writeFile-和writeFileSync"><a href="#writeFile-和writeFileSync" class="headerlink" title="writeFile()和writeFileSync()"></a>writeFile()和writeFileSync()</h5><p>用于写入文件。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>是否必须</th>
<th>例子</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件路径</td>
<td>是</td>
<td>上同</td>
<td>上同</td>
</tr>
<tr>
<td>写入的字符串或文件</td>
<td>是</td>
<td>‘hello’</td>
<td>可以是字符串，也可以是文件名，还可以是buffer </td>
</tr>
<tr>
<td>option配置</td>
<td>否</td>
<td>上同</td>
<td>上同</td>
</tr>
<tr>
<td>写入完成时的回调</td>
<td>是</td>
<td>上同</td>
<td>上同</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(&apos;message.txt&apos;, &apos;Hello Node.js&apos;, (err) =&gt; &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(&apos;The file has been saved!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里的官方文档上写了注意……多次对同一文件使用，而且不等待回调函数，是不安全的，对于多次写入同一文件，强烈建议使用fs.createWriteStream</p>
<h5 id="fs-createWriteStream"><a href="#fs-createWriteStream" class="headerlink" title="fs.createWriteStream()"></a>fs.createWriteStream()</h5><p>这个方法，创建了一个写入数据流的对象，该对象的write方法用于写入数据，end方法用于结束写入操作…..<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const out = fs.createWriteStream(fileName, &#123;</span><br><span class="line">  flags: &apos;w&apos;,</span><br><span class="line">  encoding: &apos;utf8&apos;,</span><br><span class="line">  fd: null,</span><br><span class="line">  mode: 0o666,</span><br><span class="line">  autoClose: true</span><br><span class="line">&#125;)</span><br><span class="line">out.write(str)</span><br><span class="line">out.end()</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>是否必须</th>
<th>作用 </th>
</tr>
</thead>
<tbody>
<tr>
<td>文件路径</td>
<td>是</td>
<td>略</td>
</tr>
<tr>
<td>options</td>
<td>是</td>
<td>一些配置，具体的配置有flags：一个string，大概是写入的模式比如w，r+等，encoding：编码；fd；mode；autoClose：设置是否自动关闭；start：一个integer</td>
</tr>
</tbody>
</table>
<p>注意： 如果autoClose设置为true（默认），则在遇到error和end的时候，会自动关闭，如果是false，即使有错误，也不会被关闭，所以要注意了，你要正确的负责关闭。，并确保文件描述符没有泄露， fd和mode暂时还不知道它的作用。</p>
<p>如果要对统一文件进行反复的读写，知道一直不停的out.write()就可以了，最后别忘记end()</p>
<p>相对的createWriteStream和它一样使用，但是它会返回一个ReadStream可读流对象。而且它第二个参数options中对了一个end字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.createReadStream(&apos;sample.txt&apos;, &#123; start: 90, end: 99 &#125;);</span><br><span class="line">// 设置了start和end之后，使其可以从文件读取一定范围的字节而不是整个文件</span><br></pre></td></tr></table></figure></p>
<h5 id="createWriteStream和createReadSteam结合使用拷贝大文件实例"><a href="#createWriteStream和createReadSteam结合使用拷贝大文件实例" class="headerlink" title="createWriteStream和createReadSteam结合使用拷贝大文件实例"></a>createWriteStream和createReadSteam结合使用拷贝大文件实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const fileCopy = (filename1, filename2, done) =&gt; &#123;</span><br><span class="line">  let input = fs.createReadStream(filename1);</span><br><span class="line">  let output = fs.createWriteStream(filename2);</span><br><span class="line"></span><br><span class="line">  input.on(&apos;data&apos;, function(d) &#123; output.write(d) &#125;) </span><br><span class="line">  input.on(&apos;error&apos;, function(error) &#123; throw error &#125;) </span><br><span class="line">  input.on(&apos;end&apos;, function() &#123;</span><br><span class="line">    output.end()</span><br><span class="line">    if (done) done();</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、文件的操作"><a href="#二、文件的操作" class="headerlink" title="二、文件的操作"></a>二、文件的操作</h3><h5 id="exist-、mkdir"><a href="#exist-、mkdir" class="headerlink" title="exist() 、mkdir()"></a>exist() 、mkdir()</h5><p>exist()判断文件目录是否存在，他的回调函数参数，是不管最后结果如何都会调用的，需要注意的是，以前我们写java的文件IO，在打开文件的时候都需要先用类似方法判断目录是否存在，但是node里边，open方法本身就能检查，<br>mkdir()用于新建目录，它接收三个参数，目录名、权限值和回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">// 如果给定目录存在，就删除它。</span><br><span class="line">if(fs.existSync(outputFolder)) &#123;</span><br><span class="line">  console.log(&apos;删除&apos; + outputFolder)</span><br><span class="line">  fs.rmdirSync(outputFolder)</span><br><span class="line">&#125;</span><br><span class="line">//  新建目录</span><br><span class="line">fs.mkdir(&apos;./helloDir&apos;,0777, function (err) &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h5 id="stat"><a href="#stat" class="headerlink" title="stat()"></a>stat()</h5><p>它用来判断是一个文件还是一个目录，接收一个文件或者目录。</p>
<h5 id="watch"><a href="#watch" class="headerlink" title="watch()"></a>watch()</h5><p>监控文件，如果文件发生变化，则触发回调函数。返回的是一个fs.FSWatch<br>参数 | 是否必须 | 作用<br>—-| —- | —-<br>文件名 | 是 | 略<br>options参数 | fou | 如果指定，则是一个对象，包括persistet：布尔值（默认true），表明文件被监控时，进程是否还要继续运行； recursive：指明是否全部子目录应该被监视，或只是当前目录（默认false）；encoding：默认utf-8<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.watch(&apos;somedir&apos;, (eventType, filename) =&gt; &#123;</span><br><span class="line">  console.log(`事件类型是: $&#123;eventType&#125;`);</span><br><span class="line">  if (filename) &#123;</span><br><span class="line">    console.log(`提供的文件名: $&#123;filename&#125;`);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&apos;未提供文件名&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>注意，还有一个watchFile()，作用和它差不多，效率低，官方建议用这个。但fs.watch API 不是 100％ 跨平台一致的，且在某些情况下不可用。递归选项只支持 macOS 和 Windows</p>
<h5 id="fs-lstat-path"><a href="#fs-lstat-path" class="headerlink" title="fs.lstat(path)"></a>fs.lstat(path)</h5><p>接收一个文件url，返回一个fs.Stats实例，他的同步方法是fs.lstatSync(path)</p>
<h3 id="三、webpack应用，写一个多入口的初始化entry函数"><a href="#三、webpack应用，写一个多入口的初始化entry函数" class="headerlink" title="三、webpack应用，写一个多入口的初始化entry函数"></a>三、webpack应用，写一个多入口的初始化entry函数</h3><p>在使用开发react应用的时候，使用webpack打包需要有多入口的时候，也就是说，我有多个entry，每个enrty各自生成一个html模版，这个时候，我们可以写个自动脚本，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">const _ = require(&apos;lodash&apos;)</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const  path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const entryDir = path.join(__dirname, &apos;src/entry/&apos;)</span><br><span class="line">const templateFile = path.join(__dirname, &apos;index.html&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const addEntryFn = (config, key, value) =&gt; &#123;</span><br><span class="line">  console.log(`找到了entry！，key=$&#123;key&#125;,value=$&#123;value&#125;`);</span><br><span class="line">  config.entry[key] = value</span><br><span class="line">  config.plugins.push(new HtmlWebpackPlugin(</span><br><span class="line">    &#123;</span><br><span class="line">      title: key,</span><br><span class="line">      filename: key + &apos;.html&apos;,</span><br><span class="line">      chunks: [key],</span><br><span class="line">      template: templateFile,</span><br><span class="line">      multihtmlCache: true,</span><br><span class="line">    &#125;</span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getEntrys = (config, rootpath, fn) =&gt; &#123;</span><br><span class="line">  const files = fs.readdirSync(rootpath)</span><br><span class="line">  for(let key in files) &#123;</span><br><span class="line">    const fullName = path.join(rootpath, &quot;/&quot;, files[key])</span><br><span class="line">    const stat = fs.lstatSync(fullName)</span><br><span class="line">    if (stat.isDirectory()) &#123;</span><br><span class="line">      getEntrys(config, fullName, fn)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const fileName = path.basename(fullName, &apos;.jsx&apos;)</span><br><span class="line">      if (_.startsWith(fileName, &apos;entry-&apos;)) &#123;</span><br><span class="line">        const entryKey = fileName.replace(&apos;entry-&apos;, &apos;&apos;)</span><br><span class="line">        fn(config, entryKey, fullName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> module.exports = function (config) &#123;</span><br><span class="line">  getEntrys(config, entryDir, addEntryFn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/18/Node笔记-反向代理的nodeJS实践/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geek720">
      <meta itemprop="description" content="记录日常，谢谢大家">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geek720的日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/18/Node笔记-反向代理的nodeJS实践/" class="post-title-link" itemprop="http://yoursite.com/index.html">Node笔记--------反向代理的nodeJS实践</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-18 17:36:04 / 修改时间：17:36:13" itemprop="dateCreated datePublished" datetime="2018-12-18T17:36:04+08:00">2018-12-18</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>最近在学习nginx，其中一个最重要的概念就是反向代理，但是反向代理究竟是什么？</p>
<blockquote>
<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
</blockquote>
<p>这是百度百科上给出的标准答案，但是光看定义根本完全不懂啊！所以我们先来明白，代理是怎么样的一个概念。</p>
<blockquote>
<p>代理 （proxy）在百科上的释义： 代理也称代理服务器（Proxy Server），主要工作在会话层。指以代理服务器的方式来接收internet上的连接请求，然后将请求转发给内部网络上的服务器。</p>
</blockquote>
<p>总而言之，它就是一个委托人的作用。</p>
<h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>代理也分两种，正向代理和反向代理，这里先介绍正向代理。<br>正向代理是一般常见的代理方式，客户机访问不到原始服务器的情况下，转而将请求发送给正向代理服务器，正向代理服务器将资源从原始服务器中取回来，在发送给客户机。正向代理的一般用途就是为在防火墙内的客户机提供访问internet的途径。</p>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>客户机像反向代理服务器发送请求，反向代理服务器判断要把请求发送给哪个原始服务器。这里与正向代理不同的是，反向代理服务器客户机是不用进行设置的。所以一般也用在网站的负载均衡上。</p>
<h4 id="反向代理的实践"><a href="#反向代理的实践" class="headerlink" title="反向代理的实践"></a>反向代理的实践</h4><p>这里先不讲nginx的反向代理的实现，有机会再另起一篇文章……这里来实现一个反向代理服务器。</p>
<ol>
<li>需求<br>网站上的public/image/目录下有图片资源，用户在敲入/images/xxxxx的时候会访问图片，这时候我们想先让请求跳转到cdn服务器上（现在的web框架下一般会把图片资源都放在一个专门的cdn服务器上来使用户高速访问），如果cdn服务器上没有该图片资源，则在/public/images/下查找。</li>
<li>解决方案<br>这种需求很符合代理类型中的反向代理，用户发送请求给代理，代理判断该请求是该发往cdn服务器去取资源，还是在本服务器取资源。而正向代理需要用户自己设置去哪里取资源….好蠢。</li>
<li>技术选型<br>NodeJs</li>
</ol>
<h5 id="第一步：使用express框架先搭建一个简单的服务器"><a href="#第一步：使用express框架先搭建一个简单的服务器" class="headerlink" title="第一步：使用express框架先搭建一个简单的服务器"></a>第一步：使用express框架先搭建一个简单的服务器</h5><p>index.js，这个文件就是启动服务器的主文件，撸代码之前你得确定你已经稳定安装了node环境……<br>我们先来梳理下整个小项目的目录<br><img src="http://upload-images.jianshu.io/upload_images/2204576-e75fcff418f6b909.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整个项目的目录"></p>
<ol>
<li>index.js 是项目启动的主文件</li>
<li>public/images： 项目的资源目录</li>
<li>config.json： 项目的配置json</li>
<li>node_moudles：npm自动生成的依赖包文件夹</li>
<li>package.json： node的经典文件，npm init会生成<br>首先你要先运行，来安装express依赖。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express --save</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line"></span><br><span class="line">const app =  express();</span><br><span class="line">app.get(&apos;/&apos;, function (req, res) &#123;</span><br><span class="line">  res.send(&apos;Hello World!&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(8080)</span><br></pre></td></tr></table></figure>
<p>在浏览器上访问8080端口看到有HelloWorld就算成功了！</p>
<h5 id="第二步-：在config-json下配置你的cdn服务器"><a href="#第二步-：在config-json下配置你的cdn服务器" class="headerlink" title="第二步 ：在config.json下配置你的cdn服务器"></a>第二步 ：在config.json下配置你的cdn服务器</h5><p>既然要跳转到cdn服务器，首先就需要一个cdn服务器的baseUrl，在这里我们将这个url配置成一个全局变量放在config.json中，这里我因为没有别的另外的服务器，我就随便写一个，反正只要跳转就好了嘛。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// config.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;baseImageUrl&quot;: &quot;https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="第三步：-配置反向代理逻辑"><a href="#第三步：-配置反向代理逻辑" class="headerlink" title="第三步： 配置反向代理逻辑"></a>第三步： 配置反向代理逻辑</h5><p>这一步首先要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express-http-proxy --save</span><br></pre></td></tr></table></figure></p>
<p>我们首先下载express的代理中间件，这个包里边有个proxy()来完成反向代理。<br>还是在index.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line">const proxy = require(&apos;express-http-proxy&apos;)</span><br><span class="line">const baseImageUrl = require(&apos;./config.json&apos;).baseImageUrl</span><br><span class="line"></span><br><span class="line">const proxyBsaeImageUrl = baseImageUrl</span><br><span class="line">  ? proxy(baseImageUrl, &#123;</span><br><span class="line">      proxyReqPathResolver: function(req) &#123;</span><br><span class="line">        const newPath = baseImageUrl + req.path;</span><br><span class="line">        console.log(&apos;newPath: &apos; + newPath)</span><br><span class="line">        return newPath</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  : express.static(path.join(__dirname, &apos;public/images&apos;))</span><br><span class="line"></span><br><span class="line">const app =  express();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(&apos;/images&apos;, proxyBsaeImageUrl)</span><br><span class="line">app.listen(8080)</span><br></pre></td></tr></table></figure></p>
<ol>
<li>这里我们使用了proxyBaseImageUrl来设置跳转的url，使用app.use()方法来跳转</li>
<li>proxyBaseImageUrl的返回是整个反向代理的关键，首先使用proxy()方法，将头url传入，然后在proxyReqPathResolver中将url拼接完成。proxyReqPathResolver是完成在反向代理之前路径的修改操作等。</li>
</ol>
<p>最后就是在localhost中敲入/images/xxxxxx，它会跳转到百度中去搜索……整个逻辑都是在proxyReqPathResolver完成的，如果你想要更简单的反向代理逻辑可以写的更完整！</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/18/JavaScript的一些思考，原生继承的问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geek720">
      <meta itemprop="description" content="记录日常，谢谢大家">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geek720的日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/18/JavaScript的一些思考，原生继承的问题/" class="post-title-link" itemprop="http://yoursite.com/index.html">JavaScript的一些思考，原生继承的问题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-18 17:34:14 / 修改时间：17:34:39" itemprop="dateCreated datePublished" datetime="2018-12-18T17:34:14+08:00">2018-12-18</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在使用java语言的同时，也思考过怎么用js来进行面向对象的编程，JS在es6之后，引入了class和extend等关键词，我感觉它已经渐渐步入了面向对象编程语言的行列之中，但是在这之前，是怎么样进行一系列的面向对象操作的呢？这里我是看了阮一峰老师的教程而产生的总结：</p>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/objectoriented_javascript_encapsulation.html" target="_blank" rel="noopener">Javascript 面向对象编程</a></p>
</blockquote>
<h2 id="一、封装"><a href="#一、封装" class="headerlink" title="一、封装"></a>一、封装</h2><p>简单来说，按我的理解，封装就是将一系列的有特征的实例，抽象出来，形成一种模版，类似于java种的class。产生了这种模版之后，我们可以new出来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line">   <span class="keyword">this</span>.color = color;</span><br><span class="line"> &#125;</span><br><span class="line"> Cat.prototype.type=<span class="string">"猫科动物"</span></span><br><span class="line"> Cat.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   alert(<span class="string">"吃老鼠"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里我们将一系列的实例抽象成Cat这个function（一般也认为是类），所以，我们new出来的实例，它都有这个模版的特征。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"123"</span>, <span class="string">"yellow"</span>)</span><br><span class="line"><span class="keyword">var</span> cat2  = <span class="keyword">new</span> Cat(<span class="string">"456"</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(cat1.name) <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.type) <span class="comment">// 猫</span></span><br></pre></td></tr></table></figure></p>
<p>这样的就叫封装了一个对象了，在java中就和这样类似<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String color;</span><br><span class="line">  <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="comment">// .....get函数和set函数</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-关键字prototype"><a href="#1-关键字prototype" class="headerlink" title="1.关键字prototype"></a>1.关键字prototype</h4><p>在这里我们使用prototype关键字进行对一些不变属性的定义，这个关键字也会为以后的继承起到一定的作用。<br>我们创建的每个函数都有一个<code>prototype</code>属性，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。那么，<code>prototype</code>就是通过调用构造函数而创建的那个对象实例的原型对象。<br>使用原型的好处是可以让对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中添加定义对象信息，而是可以直接将这些信息添加到原型中。使用构造函数的主要问题就是每个方法都要在每个实例中创建一遍。</p>
<blockquote>
<p>经验之谈： 把不变的属性和方法，绑在prototype对象上，而不能把可变属性绑上去。</p>
</blockquote>
<h4 id="2-关键字this"><a href="#2-关键字this" class="headerlink" title="2.关键字this"></a>2.关键字this</h4><p>使用this了之后，在cat1和cat2实例中，都会有一个constructor属性，指向他们的构造函数，可以使用<code>instanceof</code>关键字验证<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert( cat1 <span class="keyword">instanceof</span> Cat); <span class="comment">//true</span></span><br><span class="line">alert( cat2 <span class="keyword">instanceof</span> Cat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-isPrototypeOf"><a href="#3-isPrototypeOf" class="headerlink" title="3.isPrototypeOf()"></a>3.isPrototypeOf()</h4><p>这个方法用来判断实例是否继承与某个对象，也就是说判断某个proptotype对象和某个实例之间的关系。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　alert(Cat.prototype.isPrototypeOf(cat1)); <span class="comment">//true</span></span><br><span class="line">　alert(Cat.prototype.isPrototypeOf(cat2)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="4-hasOwnProperty-in运算符"><a href="#4-hasOwnProperty-in运算符" class="headerlink" title="4.hasOwnProperty() / in运算符"></a>4.hasOwnProperty() / <code>in</code>运算符</h4><p>这个方法用来判断一个实例的属性是自己的本地属性还是继承自父类对象的prototype的属性，in运算符来判断某个实例是否含有某个属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(cat1.hasOwnProperty(<span class="string">'name'</span>)) <span class="comment">//true</span></span><br><span class="line">alert(cat1.hasOwnProperty(<span class="string">'type'</span>)) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> cat1) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h2><h4 id="1-简单的prototype模式-构造函数继承"><a href="#1-简单的prototype模式-构造函数继承" class="headerlink" title="1. 简单的prototype模式(构造函数继承)"></a>1. 简单的prototype模式(构造函数继承)</h4><p>现在有个父类，比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.species = <span class="string">"动物"</span></span><br></pre></td></tr></table></figure></p>
<p>要使新的子类Cat继承这个Animal<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name , color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.color = color</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f.prototype = Animal.prototype</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> f()</span><br><span class="line">Cat.prototype.constructor = Cat</span><br><span class="line"></span><br><span class="line">Cat cat1 = <span class="keyword">new</span> Cat(<span class="string">"123"</span>, <span class="string">"yellow"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(cat1)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2204576-bc4b150b0d2dfa7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="console的cat1"></p>
<h4 id="2-深拷贝模式-非构造函数模式"><a href="#2-深拷贝模式-非构造函数模式" class="headerlink" title="2. 深拷贝模式(非构造函数模式)"></a>2. 深拷贝模式(非构造函数模式)</h4><p>如果说我们的实例不是用new出来的，只是一个简简单单的纯对象，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Chinese = &#123;</span><br><span class="line">  nation: &quot;中国&quot;</span><br><span class="line">&#125;</span><br><span class="line">var Doctor = &#123;</span><br><span class="line">  career: &quot;医生&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果说我们要医生去继承中国，使之成为一个中国医生，一个很简单的方法就是x写一个object()，将子对象的prototype属性指向父对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  f.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> f()</span><br><span class="line">&#125;</span><br><span class="line">  Doctor = object(Chinese)</span><br><span class="line">  Doctor.carrer = <span class="string">'医生'</span></span><br></pre></td></tr></table></figure></p>
<p>同样的我们也可以采用拷贝模式，把父类所有的属性拷贝到子对象，这也是lodash源码中assign方法中所使用的方案。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">p, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = c || &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> p[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">      c[i] == (p[i].constructor ===  <span class="string">'Array'</span> ?  [] : &#123;&#125;)</span><br><span class="line">       extend(p[i], c[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         c[i] = p[i]</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/13/今天看到的骚操作（1）-或运算符和闭包/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="geek720">
      <meta itemprop="description" content="记录日常，谢谢大家">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="geek720的日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/13/今天看到的骚操作（1）-或运算符和闭包/" class="post-title-link" itemprop="http://yoursite.com/index.html">今天看到的骚操作（1）-  或运算符和闭包</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-13 14:52:36 / 修改时间：14:52:56" itemprop="dateCreated datePublished" datetime="2018-12-13T14:52:36+08:00">2018-12-13</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天在网上看到一段代码，感觉很惊奇，因为它涉及到很多的知识点，有闭包，有||运算符的神奇使用等等。<br>先上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var memoize = function(f) &#123;</span><br><span class="line">  var cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    var arg_str = JSON.stringify(arguments);</span><br><span class="line">    cache[arg_str] = cache[arg_str] || f.apply(f, arguments);</span><br><span class="line">    return cache[arg_str];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">var squareNumber  = memoize(function(x)&#123; return x*x; &#125;);</span><br><span class="line"></span><br><span class="line">squareNumber(4);</span><br><span class="line">//=&gt; 16</span><br><span class="line"></span><br><span class="line">squareNumber(4); // 从缓存中读取输入值为 4 的结果</span><br><span class="line">//=&gt; 16</span><br><span class="line"></span><br><span class="line">squareNumber(5);</span><br><span class="line">//=&gt; 25</span><br><span class="line"></span><br><span class="line">squareNumber(5); // 从缓存中读取输入值为 5 的结果</span><br><span class="line">//=&gt; 25</span><br></pre></td></tr></table></figure></p>
<p>这是今天看JavaScript函数式编程的一本gitbook上找到的<a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#%E8%BF%BD%E6%B1%82%E2%80%9C%E7%BA%AF%E2%80%9D%E7%9A%84%E7%90%86%E7%94%B1" target="_blank" rel="noopener">https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#%E8%BF%BD%E6%B1%82%E2%80%9C%E7%BA%AF%E2%80%9D%E7%9A%84%E7%90%86%E7%94%B1</a><br>这一章里面原意是讲纯函数的一些实现方式和有点，但是看到这段代码，我感觉笔者的代码非常常简单，虽然这里面涉及到了闭包，以及一些逻辑运算符的骚操作，但是一眼看去还是知道作者想要实现一些什么的。</p>
<h2 id="代码本意"><a href="#代码本意" class="headerlink" title="代码本意"></a>代码本意</h2><p>这一段代码是讲两数相乘，但是会把乘过的数保存在一个叫cache的对象里，比如你已经计算过5 * 5了，他会把这个计算表达式和结果以键值对的方式存储在这个cache对象中，但是这个cache只是函数里的一个变量，无法全局保存，这里他使用到了闭包。使其在函数作用域结束的时候不会被系统销毁。</p>
<h2 id="可以学习的点"><a href="#可以学习的点" class="headerlink" title="可以学习的点"></a>可以学习的点</h2><ol>
<li>优化，以前再刷算法题的时候有过这样的场景，就是在做重复计算的时候，用什么方法可以减少计算时间，这里的缓存，可以用作这一方法。</li>
<li>|| 运算的神奇作用，以前很喜欢用&amp;&amp;做短路运算，也就是&amp;&amp;之前的表达式计算为false的时候，会直接返回，并不会计算之后的表达式，也是一种代码优化。而||，我查了下，总结来说就是返回第一个真值，如果||左边的表达式是真的话，那右边的计算就不会进行了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var temp = 5 || ( console.log(&apos;计算了右值&apos;) )</span><br><span class="line">console.log(temp); </span><br><span class="line">// 控制台打印只显示5</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>|| 返回第一个真值，&amp;&amp;返回第一个假值<br>js里边能判断为假值的有以下：</p>
<ul>
<li>null；</li>
<li>NaN；</li>
<li>0；</li>
<li>空字符串（””）；</li>
<li>undefined</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">geek720</p>
              <p class="site-description motion-element" itemprop="description">记录日常，谢谢大家</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">geek720</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
